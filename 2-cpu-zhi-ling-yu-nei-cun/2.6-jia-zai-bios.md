# 2.6 加载BIOS

一旦我们获得了BIOS，剩下的部分就相当简单了。我们只需将文件写入一个512KB缓冲区即可：

```rust
/// BIOS 镜像
pub struct Bios {
    /// BIOS 内存
    data: Vec<u8>
}

impl Bios {

    /// 从地址PATH指定的文件加载BIOS镜像
    pub fn new(path: &Path) -> Result<Bios> {

        let file = try!(File::open(path));

        let mut data = Vec::new();

        // 加载BIOS
        try!(file.take(BIOS_SIZE).read_to_end(&mut data));

        if data.len() == BIOS_SIZE as usize {
            Ok(Bios { data: data })
        } else {
            Err(Error::new(ErrorKind::InvalidInput,
                           "Invalid BIOS size"))
        }
    }
}

/// BIOS镜像的大小一定是512KB
const BIOS_SIZE: u64 = 512 * 1024;
```

> 这段Rust代码定义了一个名为Bios的结构体，表示BIOS镜像。它具有一个名为data的字段，它是一个u8类型的向量，用于存储BIOS镜像在内存中的内容。
>
> 该结构体还有一个实现块，包含一个名为new的公共函数。此函数将从给定路径的文件中加载BIOS镜像。它首先尝试打开指定的文件，然后创建一个空的向量data，用于存储加载的BIOS数据。然后，它从文件中读取大小为BIOS\_SIZE的数据并将其写入data向量中。
>
> 最后，该函数检查data向量的长度是否等于BIOS\_SIZE，如果是，则返回包含data向量的Bios实例。如果不是，则返回一个表示无效BIOS大小的错误。
>
> 此外，代码中定义了一个常量BIOS\_SIZE，其值为512 \* 1024，表示BIOS镜像的大小始终为512KB。

我们还需要能够从BIOS中读取数据。CPU需要读取32位数据以加载指令，因此让我们开始实现load32函数：

```rust
impl Bios {
    // ...

    /// 获取偏移量为offset的32位小端字节顺序数据
    pub fn load32(&self, offset: u32) -> u32 {
        let offset = offset as usize;

        let b0 = self.data[offset + 0] as u32;
        let b1 = self.data[offset + 1] as u32;
        let b2 = self.data[offset + 2] as u32;
        let b3 = self.data[offset + 3] as u32;

        b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)
    }
}
```

> 这段Rust代码实现了Bios结构体的load32方法。load32方法用于从BIOS中获取32位的little-endian字节序列（按照从低地址到高地址的顺序存储数据），并返回对应的32位无符号整数。该方法的参数是一个32位无符号整数offset，表示要获取的字节序列在BIOS中的偏移量。方法内部先将偏移量转换为usize类型，然后通过下标操作从self.data字段中读取四个字节的数据（类型为u8），分别赋值给b0、b1、b2、b3变量。最后，使用位运算符将这四个字节组合成一个32位无符号整数，并返回该整数。

需要注意的几件事情：偏移量并不是CPU使用的绝对地址，它只是BIOS内存范围内的偏移量。请记住，BIOS被映射到多个区域，因此我们将在**通用互连代码\[1]** 中处理它。每个外设只处理其地址范围内的偏移量。

在注释中，我提到我们以小端方式读取4字节数据。这非常重要。如果您以前从未考虑过字节序问题，让我简要介绍一下。

内存的基本单位是字节（PSX是8位）。您无法寻址比一个字节更小的任何东西。然而，有时您需要跨多个字节存储数据。例如，我们已经看到我们的指令有4个字节长。我们有多种方法将4个字节的单词存储在我们的“字节数组”中。

举个例子：你有一个32位的数据0x12345678。你有多种方法将该值存储在4个连续的字节中。例如，我们可以存储\[0x12，0x34，0x56，0x78]或\[0x78，0x56，0x34，0x12]。前者称为大端字节序，因为我们首先存储最高位的字节(0x12)。后者称为小端字节序，因为我们首先存储最低位的字节(0x78)。还有其他更奇怪的字节序类型，但在现代计算机中很少使用。如果您想了解更多细节，请查看维基百科。

PlayStation采用小端字节序，因此我们处于第二种情况：在读取或写入多字节值时，最低位字节先进行读取或写入。如果我们反过来操作，我们将得到无意义数据。

现在我们可以实现我们的**互连\[2]** ，让CPU与BIOS通信。

**\[1] 通用互连代码**是指用于在计算机系统中连接不同组件或外设的通用代码，它提供了一种抽象化的方式来处理不同组件之间的通信。这些组件可以是CPU、内存、外围设备等。通用互连代码的目的是使这些组件之间的通信更加简化和可靠，从而提高系统的可维护性和可扩展性。

**\[2]互连** 是指在计算机系统中不同组件之间进行通信和数据传输的方式和技术。在计算机系统中，不同的硬件组件需要相互协作才能完成各种任务。例如，在计算机中，CPU需要与内存、I/O设备、存储设备等各种硬件组件进行通信。这些组件之间的通信和数据传输需要通过一些特定的技术和协议来实现，这些技术和协议就被称为互连技术和互连协议。在计算机系统的设计和实现中，互连是一个非常重要的问题，因为良好的互连设计可以提高系统的性能和可靠性。
